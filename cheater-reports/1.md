# Clumsyoof
**To preface,**

The user *Clumsyoof* registered on codeforces two (2) days ago, and has participated in the recent Div. 2 contests on Friday and Saturday.



The concerns I have are drawn on from the fact that this user has solved (A-D) in both contests, and with good time.

Regardless, I would like to draw attention on the actual submission content itself.

first -- please read the submission timings:

352237373 Dec/06/2025 11:07UTC+1 C 	AC

352228498 Dec/06/2025 10:41UTC+1 D 	AC

352223023 Dec/06/2025 10:26UTC+1 B AC


352219051 Dec/06/2025 10:16UTC+1 A AC

this was in cf round 1069 div.2. everyone I have talked to including myself agree that C was one of the most trivial problems (you just read it and write it down), the fact that the person couldnt recognise this and skipped to D -- solving it -- and coming back, is already rather shocking.


secondly -- the way they write solutions is rather suspicious and give a very clear sign of AI use.

see problems A-D:
```cpp
//problem a cf 1069
// headers -- bits/stdc++.h not used? fine
void solve() {
    /*
    Code . . .
     */
    // i think when solving this problem, writing down comments isnt that necessary but thats my own semantic.
    // clumsyoof:
        // Loop until we find a k that is already in our set of colors.
        // Since max(a_i) is 1000, this loop will terminate very quickly.
    // code ...
    }
     
int main() {
    // Fast I/O <- why do we need to point this out? ok, maybe new.
    // ... code ...
}

```
well, this is rather fine, lets look at b
```cpp
//problem b cf 1069 

i wont put most of the code to save space, but see comments they wrote:
// Step 2: Force the specific pair (l-1, r) to be equal.
        // We pick a "Magic Number" that is larger than n so it doesn't collide
        // with the values we just assigned (0 to n).
        // 2^20 is approx 1,000,000, which is safe.
        // Step 3: Reconstruct the array 'a' from the prefix array
        // a[i] = p[i] XOR p[i-1]
```
 as i stated before, I think this is an excess of comments, sure sometimes it is nice to document the constraints but mid-contest not so much. but again, thats just semantics.


now, the surprising part: why do D first instead of C?
who tf knows. anyways, lets look at the solution for D:

```cpp
//problem d cf 1069
void solve()
{
    if (!(cin >> n >> k)) return;
    // either they didnt realise submissions are guaranteed to have appropriate test cases or they used ai.
}
// same in main:
int main()
{
    // i really hope domjudge gives input.. dont really need if()..
    if (cin >> t) {
        while (t--) {
            solve();
        }
}
```
ok, that was weird, doesnt look so great. plus the constants and code look rather ai generated in the style, but thats semantics again.

lets look at his (now) c which he skipped for some reason( when his ai was computing.. ?)

```cpp
//problem c cf 1069
// same issues again..
if (!(cin >> s >> t)) return;
// one doesnt need this since testcases are appropriate.
    if (cin >> t) {
        while (t--) {
            solve();
        }
    }
// this again.. getting tired of the weird conditions.
```
one may ask, well if they took so long to do c, how can they do D so easily, meh, AI.

so lets check D from codeforces div 2 1068 - "Taigas carry chains"

```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
     
    using namespace std;
     
    // Function to calculate extra score from resolving a remaining carry into empty space
    // e.g., if carry is 2 (binary 10), it adds to 0 -> 10.
    // 0 + 2 = 0, carry 1. Next 0 + 1 = 1. Total 1 carry generated.
    int resolve_carry(int c) {
        int score = 0;
        while (c > 0) {
            score += c / 2;
            c /= 2;
        }
        return score;
    }
     
    void solve() {
        long long n, k;
        if (!(cin >> n >> k)) return;
     
        // We only need to process bits up to ~32 since n < 2^30.
        // However, carries can push slightly higher, so 34 is safe.
        int max_bits = 34;
        
        // Limits for DP
        // If k is huge, we can simply assume we have enough moves to do whatever we want 
        // for the lower bits, and use the rest for infinite doubling at the end.
        // We cap 'j' (moves used) at max_bits + 2 because using more moves on lower bits
        // than there are bits is generally inefficient or covered by the loop.
        int limit_k = min((long long)max_bits + 2, k);
     
        // dp[i][j][c] = max score
        // i: current bit index (0 to max_bits)
        // j: moves used
        // c: carry value coming in. Max carry?
        // Max sum at a bit = 1 (n[i]) + 1 (insert) + c.
        // If c is 2, sum is 4 -> carry out 2. c never exceeds 2.
        // We use c up to 3 for safety.
        vector<vector<vector<long long>>> dp(max_bits + 1, 
            vector<vector<long long>>(limit_k + 1, 
            vector<long long>(3, -1)));
     
        dp[0][0][0] = 0;
     
        for (int i = 0; i < max_bits; i++) {
            int bit = (n >> i) & 1;
            
            for (int j = 0; j <= limit_k; j++) {
                for (int c = 0; c <= 2; c++) {
                    if (dp[i][j][c] == -1) continue;
     
                    // Try inserting x moves at this bit position (x = 0 or 1)
                    // We don't strictly need x > 1 because 2*2^i = 2^{i+1}, handled at next step.
                    for (int x = 0; x <= 1; x++) {
                        if (j + x > limit_k) continue;
     
                        int sum = bit + c + x;
                        int carry_out = sum / 2;
                        // Ensure carry doesn't exceed bounds (unlikely with x<=1)
                        if (carry_out > 2) continue; 
     
                        long long next_score = dp[i][j][c] + carry_out;
                        
                        dp[i + 1][j + x][carry_out] = max(dp[i + 1][j + x][carry_out], next_score);
                    }
                }
            }
        }
     
        long long ans = 0;
     
        // Check all final states
        for (int j = 0; j <= limit_k; j++) {
            for (int c = 0; c <= 2; c++) {
                if (dp[max_bits][j][c] == -1) continue;
     
                // 1. The score accumulated in DP
                long long current_total = dp[max_bits][j][c];
                
                // 2. The score from resolving the final carry into zeros
                current_total += resolve_carry(c);
                
                // 3. The score from leftover moves (doubling the MSB repeatedly)
                // Each unused move gives +1 score (e.g., 2^M + 2^M = 2^{M+1}, 1 carry)
                long long unused_moves = k - j;
                if (unused_moves > 0) {
                    current_total += unused_moves;
                }
     
                ans = max(ans, current_total);
            }
        }
     
        cout << ans << "\n";
    }
     
    int main() {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        int t;
        if (cin >> t) {
            while (t--) {
                solve();
            }
        }
        return 0;
    }
```
not even gonna comment on that.. wow, that is way too many comments for something developed mid contest with a delta time between solving c and d being only 30 minutes!!
```
352095032 	Dec/05/2025 17:26UTC+1 	Clumsyoof 	D - Taiga's Carry Chains 	C++20 (GCC 13-64) 	Accepted 	296 ms 	100 KB
352078365 	Dec/05/2025 16:50UTC+1 	Clumsyoof 	C - Kanade's Perfect Multiples 	C++20 (GCC 13-64) 	Accepted 	125 ms 	3400 KB 
```
I believe this is rather clear evidence of cheating, so many comments and weird logic, weird conditionals, are clear signs of AI and hence they deserve to be marked as cheater. Thank you.
